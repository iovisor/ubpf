<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uBPF: vm/inc/ubpf.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">uBPF
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_93effe02d2e8dd09437fb49d0adaddf7.html">vm</a></li><li class="navelem"><a class="el" href="dir_cf6c78462b393272f91793a3a49557d3.html">inc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ubpf.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;ubpf_config.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
</div>
<p><a href="ubpf_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a7b029668bfe717c5d7b33fba3847a00f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a7b029668bfe717c5d7b33fba3847a00f">UBPF_MAX_INSTS</a>&#160;&#160;&#160;65536</td></tr>
<tr class="memdesc:a7b029668bfe717c5d7b33fba3847a00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum number of instructions that a program can contain.  <a href="ubpf_8h.html#a7b029668bfe717c5d7b33fba3847a00f">More...</a><br /></td></tr>
<tr class="separator:a7b029668bfe717c5d7b33fba3847a00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41a6986b0045cc2e5c84a75d08c7a12"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#ab41a6986b0045cc2e5c84a75d08c7a12">UBPF_STACK_SIZE</a>&#160;&#160;&#160;512</td></tr>
<tr class="memdesc:ab41a6986b0045cc2e5c84a75d08c7a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default stack size for the VM. Must be divisible by 16.  <a href="ubpf_8h.html#ab41a6986b0045cc2e5c84a75d08c7a12">More...</a><br /></td></tr>
<tr class="separator:ab41a6986b0045cc2e5c84a75d08c7a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e70b5f29f0296e69a72ec5cfc588d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a23e70b5f29f0296e69a72ec5cfc588d8">UBPF_MAX_CALL_DEPTH</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:a23e70b5f29f0296e69a72ec5cfc588d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum number of nested calls in the VM.  <a href="ubpf_8h.html#a23e70b5f29f0296e69a72ec5cfc588d8">More...</a><br /></td></tr>
<tr class="separator:a23e70b5f29f0296e69a72ec5cfc588d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6334115c4408267ec35087ade6128fa0"><td class="memItemLeft" align="right" valign="top">typedef uint64_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a6334115c4408267ec35087ade6128fa0">ubpf_jit_fn</a>) (void *mem, size_t mem_len)</td></tr>
<tr class="memdesc:a6334115c4408267ec35087ade6128fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a uBPF JIT compiled function.  <a href="ubpf_8h.html#a6334115c4408267ec35087ade6128fa0">More...</a><br /></td></tr>
<tr class="separator:a6334115c4408267ec35087ade6128fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c06ae6f43ae6e0cbca64ac1e70bc30"><td class="memItemLeft" align="right" valign="top">typedef uint64_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a97c06ae6f43ae6e0cbca64ac1e70bc30">external_function_t</a>) (uint64_t p0, uint64_t p1, uint64_t p2, uint64_t p3, uint64_t p4)</td></tr>
<tr class="memdesc:a97c06ae6f43ae6e0cbca64ac1e70bc30"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of an external function.  <a href="ubpf_8h.html#a97c06ae6f43ae6e0cbca64ac1e70bc30">More...</a><br /></td></tr>
<tr class="separator:a97c06ae6f43ae6e0cbca64ac1e70bc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa819644ac2adf81271cf703f9eb5614b"><td class="memItemLeft" align="right" valign="top">typedef uint64_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#aa819644ac2adf81271cf703f9eb5614b">external_function_dispatcher_t</a>) (uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, unsigned int index, void *cookie)</td></tr>
<tr class="memdesc:aa819644ac2adf81271cf703f9eb5614b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of an external helper dispatcher function.  <a href="ubpf_8h.html#aa819644ac2adf81271cf703f9eb5614b">More...</a><br /></td></tr>
<tr class="separator:aa819644ac2adf81271cf703f9eb5614b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a27475942992fb5f4b7536fc757fd7"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a28a27475942992fb5f4b7536fc757fd7">external_function_validate_t</a>) (unsigned int index, void *cookie)</td></tr>
<tr class="memdesc:a28a27475942992fb5f4b7536fc757fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of an external helper validation function.  <a href="ubpf_8h.html#a28a27475942992fb5f4b7536fc757fd7">More...</a><br /></td></tr>
<tr class="separator:a28a27475942992fb5f4b7536fc757fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fb644d080e8448c1db17bb99858391"><td class="memItemLeft" align="right" valign="top">typedef uint64_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a70fb644d080e8448c1db17bb99858391">ubpf_data_relocation</a>) (void *user_context, const uint8_t *data, uint64_t data_size, const char *symbol_name, uint64_t symbol_offset, uint64_t symbol_size)</td></tr>
<tr class="memdesc:a70fb644d080e8448c1db17bb99858391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data relocation function that is called by the VM when it encounters a R_BPF_64_64 relocation in the maps section of the ELF file.  <a href="ubpf_8h.html#a70fb644d080e8448c1db17bb99858391">More...</a><br /></td></tr>
<tr class="separator:a70fb644d080e8448c1db17bb99858391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bd2f640f675e3eeff48ea52583d699"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a64bd2f640f675e3eeff48ea52583d699">ubpf_bounds_check</a>) (void *context, uint64_t addr, uint64_t size)</td></tr>
<tr class="separator:a64bd2f640f675e3eeff48ea52583d699"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a845988047e3c2fe9713e2f8a404d0751"><td class="memItemLeft" align="right" valign="top">struct ubpf_vm *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a845988047e3c2fe9713e2f8a404d0751">ubpf_create</a> (void)</td></tr>
<tr class="memdesc:a845988047e3c2fe9713e2f8a404d0751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new uBPF VM.  <a href="ubpf_8h.html#a845988047e3c2fe9713e2f8a404d0751">More...</a><br /></td></tr>
<tr class="separator:a845988047e3c2fe9713e2f8a404d0751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69dfc8e94c60e15a5db25fb6316274f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#ae69dfc8e94c60e15a5db25fb6316274f">ubpf_destroy</a> (struct ubpf_vm *vm)</td></tr>
<tr class="memdesc:ae69dfc8e94c60e15a5db25fb6316274f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a uBPF VM.  <a href="ubpf_8h.html#ae69dfc8e94c60e15a5db25fb6316274f">More...</a><br /></td></tr>
<tr class="separator:ae69dfc8e94c60e15a5db25fb6316274f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80938918080712ac0667359fd163f1a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a80938918080712ac0667359fd163f1a5">ubpf_toggle_bounds_check</a> (struct ubpf_vm *vm, bool enable)</td></tr>
<tr class="memdesc:a80938918080712ac0667359fd163f1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable / disable bounds_check. Bounds check is enabled by default, but it may be too restrictive.  <a href="ubpf_8h.html#a80938918080712ac0667359fd163f1a5">More...</a><br /></td></tr>
<tr class="separator:a80938918080712ac0667359fd163f1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e25aeeb15d5dc04a58f99239c4774c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#ae7e25aeeb15d5dc04a58f99239c4774c">ubpf_set_error_print</a> (struct ubpf_vm *vm, int(*error_printf)(FILE *stream, const char *format,...))</td></tr>
<tr class="memdesc:ae7e25aeeb15d5dc04a58f99239c4774c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the function to be invoked if the program hits a fatal error.  <a href="ubpf_8h.html#ae7e25aeeb15d5dc04a58f99239c4774c">More...</a><br /></td></tr>
<tr class="separator:ae7e25aeeb15d5dc04a58f99239c4774c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53971fe3966198c6fec238d81d94bfe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ubpf_8h.html#a97c06ae6f43ae6e0cbca64ac1e70bc30">external_function_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a53971fe3966198c6fec238d81d94bfe8">as_external_function_t</a> (void *f)</td></tr>
<tr class="memdesc:a53971fe3966198c6fec238d81d94bfe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an external function to external_function_t Some external functions may not use all the parameters and, therefore, not match the external_function_t typedef. Use this for a conversion.  <a href="ubpf_8h.html#a53971fe3966198c6fec238d81d94bfe8">More...</a><br /></td></tr>
<tr class="separator:a53971fe3966198c6fec238d81d94bfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398c1c9b6d59876005eb64bbfab7b2b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a398c1c9b6d59876005eb64bbfab7b2b4">ubpf_register</a> (struct ubpf_vm *vm, unsigned int index, const char *name, <a class="el" href="ubpf_8h.html#a97c06ae6f43ae6e0cbca64ac1e70bc30">external_function_t</a> fn)</td></tr>
<tr class="memdesc:a398c1c9b6d59876005eb64bbfab7b2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an external function. The immediate field of a CALL instruction is an index into an array of functions registered by the user. This API associates a function with an index.  <a href="ubpf_8h.html#a398c1c9b6d59876005eb64bbfab7b2b4">More...</a><br /></td></tr>
<tr class="separator:a398c1c9b6d59876005eb64bbfab7b2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bd76bca3d6351db8e6da1d542b37fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a05bd76bca3d6351db8e6da1d542b37fa">ubpf_register_external_dispatcher</a> (struct ubpf_vm *vm, <a class="el" href="ubpf_8h.html#aa819644ac2adf81271cf703f9eb5614b">external_function_dispatcher_t</a> dispatcher, <a class="el" href="ubpf_8h.html#a28a27475942992fb5f4b7536fc757fd7">external_function_validate_t</a> validater, void *cookie)</td></tr>
<tr class="memdesc:a05bd76bca3d6351db8e6da1d542b37fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a function that dispatches to external helpers The immediate field of a CALL instruction is an index of a helper function to invoke. This API sets a callback that will choose the helper function to invoke (based on the index) and then invoke it. This API also sets a callback that the validator will use to determine if a given index is a valid external function.  <a href="ubpf_8h.html#a05bd76bca3d6351db8e6da1d542b37fa">More...</a><br /></td></tr>
<tr class="separator:a05bd76bca3d6351db8e6da1d542b37fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d32748c100c98d69dba8dcf0e9d4d0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a8d32748c100c98d69dba8dcf0e9d4d0d">ubpf_load</a> (struct ubpf_vm *vm, const void *code, uint32_t code_len, char **errmsg)</td></tr>
<tr class="memdesc:a8d32748c100c98d69dba8dcf0e9d4d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load code into a VM. This must be done before calling ubpf_exec or ubpf_compile and after registering all functions.  <a href="ubpf_8h.html#a8d32748c100c98d69dba8dcf0e9d4d0d">More...</a><br /></td></tr>
<tr class="separator:a8d32748c100c98d69dba8dcf0e9d4d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95b334d7eeb18072da3b9f4eeb66c25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#ae95b334d7eeb18072da3b9f4eeb66c25">ubpf_unload_code</a> (struct ubpf_vm *vm)</td></tr>
<tr class="memdesc:ae95b334d7eeb18072da3b9f4eeb66c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unload code from a VM.  <a href="ubpf_8h.html#ae95b334d7eeb18072da3b9f4eeb66c25">More...</a><br /></td></tr>
<tr class="separator:ae95b334d7eeb18072da3b9f4eeb66c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce3eb22d45ec43436758a139ffc8c95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a1ce3eb22d45ec43436758a139ffc8c95">ubpf_exec</a> (const struct ubpf_vm *vm, void *mem, size_t mem_len, uint64_t *bpf_return_value)</td></tr>
<tr class="memdesc:a1ce3eb22d45ec43436758a139ffc8c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a BPF program in the VM using the interpreter.  <a href="ubpf_8h.html#a1ce3eb22d45ec43436758a139ffc8c95">More...</a><br /></td></tr>
<tr class="separator:a1ce3eb22d45ec43436758a139ffc8c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b901bf6d169b6b28f818f15bd17cba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ubpf_8h.html#a6334115c4408267ec35087ade6128fa0">ubpf_jit_fn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a67b901bf6d169b6b28f818f15bd17cba">ubpf_compile</a> (struct ubpf_vm *vm, char **errmsg)</td></tr>
<tr class="memdesc:a67b901bf6d169b6b28f818f15bd17cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a BPF program in the VM to native code.  <a href="ubpf_8h.html#a67b901bf6d169b6b28f818f15bd17cba">More...</a><br /></td></tr>
<tr class="separator:a67b901bf6d169b6b28f818f15bd17cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34e26c0a46366345df354ce992448c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#ab34e26c0a46366345df354ce992448c4">ubpf_translate</a> (struct ubpf_vm *vm, uint8_t *buffer, size_t *size, char **errmsg)</td></tr>
<tr class="memdesc:ab34e26c0a46366345df354ce992448c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate the eBPF byte code to x64 machine code.  <a href="ubpf_8h.html#ab34e26c0a46366345df354ce992448c4">More...</a><br /></td></tr>
<tr class="separator:ab34e26c0a46366345df354ce992448c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0046484ecdb72363d0c5ae710e7b96c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a0046484ecdb72363d0c5ae710e7b96c3">ubpf_set_unwind_function_index</a> (struct ubpf_vm *vm, unsigned int idx)</td></tr>
<tr class="memdesc:a0046484ecdb72363d0c5ae710e7b96c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct the uBPF runtime to apply unwind-on-success semantics to a helper function. If the function returns 0, the uBPF runtime will end execution of the eBPF program and immediately return control to the caller. This is used for implementing function like the "bpf_tail_call" helper.  <a href="ubpf_8h.html#a0046484ecdb72363d0c5ae710e7b96c3">More...</a><br /></td></tr>
<tr class="separator:a0046484ecdb72363d0c5ae710e7b96c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0990b88e11d2a0ba89fbaf8086cc0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#aeb0990b88e11d2a0ba89fbaf8086cc0f">ubpf_set_registers</a> (struct ubpf_vm *vm, uint64_t *regs)</td></tr>
<tr class="memdesc:aeb0990b88e11d2a0ba89fbaf8086cc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override the storage location for the BPF registers in the VM.  <a href="ubpf_8h.html#aeb0990b88e11d2a0ba89fbaf8086cc0f">More...</a><br /></td></tr>
<tr class="separator:aeb0990b88e11d2a0ba89fbaf8086cc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e649a921bff795712a97d3ad849f6e4"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a2e649a921bff795712a97d3ad849f6e4">ubpf_get_registers</a> (const struct ubpf_vm *vm)</td></tr>
<tr class="memdesc:a2e649a921bff795712a97d3ad849f6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the storage location for the BPF registers in the VM.  <a href="ubpf_8h.html#a2e649a921bff795712a97d3ad849f6e4">More...</a><br /></td></tr>
<tr class="separator:a2e649a921bff795712a97d3ad849f6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3257e0611c177eeaba7053e2eca92701"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a3257e0611c177eeaba7053e2eca92701">ubpf_set_pointer_secret</a> (struct ubpf_vm *vm, uint64_t secret)</td></tr>
<tr class="memdesc:a3257e0611c177eeaba7053e2eca92701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional secret to improve ROP protection.  <a href="ubpf_8h.html#a3257e0611c177eeaba7053e2eca92701">More...</a><br /></td></tr>
<tr class="separator:a3257e0611c177eeaba7053e2eca92701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce8c1133902da4629c53aa82c159611"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a6ce8c1133902da4629c53aa82c159611">ubpf_register_data_relocation</a> (struct ubpf_vm *vm, void *user_context, <a class="el" href="ubpf_8h.html#a70fb644d080e8448c1db17bb99858391">ubpf_data_relocation</a> relocation)</td></tr>
<tr class="memdesc:a6ce8c1133902da4629c53aa82c159611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a relocation function for the VM.  <a href="ubpf_8h.html#a6ce8c1133902da4629c53aa82c159611">More...</a><br /></td></tr>
<tr class="separator:a6ce8c1133902da4629c53aa82c159611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286aa9da7688d1327756e967eafc2f03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubpf_8h.html#a286aa9da7688d1327756e967eafc2f03">ubpf_register_data_bounds_check</a> (struct ubpf_vm *vm, void *user_context, <a class="el" href="ubpf_8h.html#a64bd2f640f675e3eeff48ea52583d699">ubpf_bounds_check</a> bounds_check)</td></tr>
<tr class="memdesc:a286aa9da7688d1327756e967eafc2f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a bounds check function for the VM.  <a href="ubpf_8h.html#a286aa9da7688d1327756e967eafc2f03">More...</a><br /></td></tr>
<tr class="separator:a286aa9da7688d1327756e967eafc2f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a23e70b5f29f0296e69a72ec5cfc588d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e70b5f29f0296e69a72ec5cfc588d8">&#9670;&nbsp;</a></span>UBPF_MAX_CALL_DEPTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UBPF_MAX_CALL_DEPTH&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default maximum number of nested calls in the VM. </p>

</div>
</div>
<a id="a7b029668bfe717c5d7b33fba3847a00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b029668bfe717c5d7b33fba3847a00f">&#9670;&nbsp;</a></span>UBPF_MAX_INSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UBPF_MAX_INSTS&#160;&#160;&#160;65536</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default maximum number of instructions that a program can contain. </p>

</div>
</div>
<a id="ab41a6986b0045cc2e5c84a75d08c7a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41a6986b0045cc2e5c84a75d08c7a12">&#9670;&nbsp;</a></span>UBPF_STACK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UBPF_STACK_SIZE&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default stack size for the VM. Must be divisible by 16. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aa819644ac2adf81271cf703f9eb5614b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa819644ac2adf81271cf703f9eb5614b">&#9670;&nbsp;</a></span>external_function_dispatcher_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t(* external_function_dispatcher_t) (uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, unsigned int index, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of an external helper dispatcher function. </p>

</div>
</div>
<a id="a97c06ae6f43ae6e0cbca64ac1e70bc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c06ae6f43ae6e0cbca64ac1e70bc30">&#9670;&nbsp;</a></span>external_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t(* external_function_t) (uint64_t p0, uint64_t p1, uint64_t p2, uint64_t p3, uint64_t p4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of an external function. </p>

</div>
</div>
<a id="a28a27475942992fb5f4b7536fc757fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a27475942992fb5f4b7536fc757fd7">&#9670;&nbsp;</a></span>external_function_validate_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* external_function_validate_t) (unsigned int index, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of an external helper validation function. </p>

</div>
</div>
<a id="a64bd2f640f675e3eeff48ea52583d699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bd2f640f675e3eeff48ea52583d699">&#9670;&nbsp;</a></span>ubpf_bounds_check</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* ubpf_bounds_check) (void *context, uint64_t addr, uint64_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70fb644d080e8448c1db17bb99858391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fb644d080e8448c1db17bb99858391">&#9670;&nbsp;</a></span>ubpf_data_relocation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t(* ubpf_data_relocation) (void *user_context, const uint8_t *data, uint64_t data_size, const char *symbol_name, uint64_t symbol_offset, uint64_t symbol_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data relocation function that is called by the VM when it encounters a R_BPF_64_64 relocation in the maps section of the ELF file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user_context</td><td>The user context that was passed to ubpf_register_data_relocation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to start of the map section. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of the map section. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symbol_name</td><td>Name of the symbol that is referenced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symbol_offset</td><td>Offset of the symbol relative to the start of the map section. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">symbol_size</td><td>Size of the symbol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint64_t The value to insert into the BPF program. </dd></dl>

</div>
</div>
<a id="a6334115c4408267ec35087ade6128fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6334115c4408267ec35087ade6128fa0">&#9670;&nbsp;</a></span>ubpf_jit_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t(* ubpf_jit_fn) (void *mem, size_t mem_len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque type for a uBPF JIT compiled function. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a53971fe3966198c6fec238d81d94bfe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53971fe3966198c6fec238d81d94bfe8">&#9670;&nbsp;</a></span>as_external_function_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ubpf_8h.html#a97c06ae6f43ae6e0cbca64ac1e70bc30">external_function_t</a> as_external_function_t </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast an external function to external_function_t Some external functions may not use all the parameters and, therefore, not match the external_function_t typedef. Use this for a conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The function to cast to match the signature of an external function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>external function, as external_function_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67b901bf6d169b6b28f818f15bd17cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b901bf6d169b6b28f818f15bd17cba">&#9670;&nbsp;</a></span>ubpf_compile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ubpf_8h.html#a6334115c4408267ec35087ade6128fa0">ubpf_jit_fn</a> ubpf_compile </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>errmsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile a BPF program in the VM to native code. </p>
<p>A program must be loaded into the VM and all external functions must be registered before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to compile the program in. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errmsg</td><td>The error message, if any. This should be freed by the caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ubpf_jit_fn A pointer to the compiled program, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a845988047e3c2fe9713e2f8a404d0751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845988047e3c2fe9713e2f8a404d0751">&#9670;&nbsp;</a></span>ubpf_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ubpf_vm* ubpf_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new uBPF VM. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new VM, or NULL on failure. </dd></dl>

</div>
</div>
<a id="ae69dfc8e94c60e15a5db25fb6316274f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69dfc8e94c60e15a5db25fb6316274f">&#9670;&nbsp;</a></span>ubpf_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubpf_destroy </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a uBPF VM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ce3eb22d45ec43436758a139ffc8c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce3eb22d45ec43436758a139ffc8c95">&#9670;&nbsp;</a></span>ubpf_exec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_exec </td>
          <td>(</td>
          <td class="paramtype">const struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mem_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>bpf_return_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a BPF program in the VM using the interpreter. </p>
<p>A program must be loaded into the VM and all external functions must be registered before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to execute the program in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mem</td><td>The memory to pass to the program. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_len</td><td>The length of the memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bpf_return_value</td><td>The value of the r0 register when the program exits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e649a921bff795712a97d3ad849f6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e649a921bff795712a97d3ad849f6e4">&#9670;&nbsp;</a></span>ubpf_get_registers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* ubpf_get_registers </td>
          <td>(</td>
          <td class="paramtype">const struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the storage location for the BPF registers in the VM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to get the register storage from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint64_t* A pointer to the register storage. </dd></dl>

</div>
</div>
<a id="a8d32748c100c98d69dba8dcf0e9d4d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d32748c100c98d69dba8dcf0e9d4d0d">&#9670;&nbsp;</a></span>ubpf_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_load </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>code_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>errmsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load code into a VM. This must be done before calling ubpf_exec or ubpf_compile and after registering all functions. </p>
<p>'code' should point to eBPF bytecodes and 'code_len' should be the size in bytes of that buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to load the code into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>The eBPF bytecodes to load. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code_len</td><td>The length of the eBPF bytecodes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errmsg</td><td>The error message, if any. This should be freed by the caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a398c1c9b6d59876005eb64bbfab7b2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398c1c9b6d59876005eb64bbfab7b2b4">&#9670;&nbsp;</a></span>ubpf_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_register </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ubpf_8h.html#a97c06ae6f43ae6e0cbca64ac1e70bc30">external_function_t</a>&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an external function. The immediate field of a CALL instruction is an index into an array of functions registered by the user. This API associates a function with an index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to register the function on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index to register the function at. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The human readable name of the function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>The function to register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a286aa9da7688d1327756e967eafc2f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286aa9da7688d1327756e967eafc2f03">&#9670;&nbsp;</a></span>ubpf_register_data_bounds_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_register_data_bounds_check </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ubpf_8h.html#a64bd2f640f675e3eeff48ea52583d699">ubpf_bounds_check</a>&#160;</td>
          <td class="paramname"><em>bounds_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a bounds check function for the VM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to set the bounds check function for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_context</td><td>The user context to pass to the bounds check function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bounds_check</td><td>The bounds check function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ce8c1133902da4629c53aa82c159611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce8c1133902da4629c53aa82c159611">&#9670;&nbsp;</a></span>ubpf_register_data_relocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_register_data_relocation </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ubpf_8h.html#a70fb644d080e8448c1db17bb99858391">ubpf_data_relocation</a>&#160;</td>
          <td class="paramname"><em>relocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a relocation function for the VM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to set the relocation function for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relocation</td><td>The relocation function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The value to insert into the BPF program. </dd></dl>

</div>
</div>
<a id="a05bd76bca3d6351db8e6da1d542b37fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05bd76bca3d6351db8e6da1d542b37fa">&#9670;&nbsp;</a></span>ubpf_register_external_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_register_external_dispatcher </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ubpf_8h.html#aa819644ac2adf81271cf703f9eb5614b">external_function_dispatcher_t</a>&#160;</td>
          <td class="paramname"><em>dispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ubpf_8h.html#a28a27475942992fb5f4b7536fc757fd7">external_function_validate_t</a>&#160;</td>
          <td class="paramname"><em>validater</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a function that dispatches to external helpers The immediate field of a CALL instruction is an index of a helper function to invoke. This API sets a callback that will choose the helper function to invoke (based on the index) and then invoke it. This API also sets a callback that the validator will use to determine if a given index is a valid external function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to register the function on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dispatcher</td><td>The callback that will dispatch to the external helper. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">validater</td><td>The callback that will validate that a given index is valid for an external helper. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cookie</td><td>A pointer to some user-defined cookie that will be passed to the callbacks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7e25aeeb15d5dc04a58f99239c4774c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e25aeeb15d5dc04a58f99239c4774c">&#9670;&nbsp;</a></span>ubpf_set_error_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubpf_set_error_print </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(FILE *stream, const char *format,...)&#160;</td>
          <td class="paramname"><em>error_printf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the function to be invoked if the program hits a fatal error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to set the error function on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_printf</td><td>The function to be invoked on fatal error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3257e0611c177eeaba7053e2eca92701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3257e0611c177eeaba7053e2eca92701">&#9670;&nbsp;</a></span>ubpf_set_pointer_secret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_set_pointer_secret </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>secret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional secret to improve ROP protection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to set the secret for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secret</td><td>Optional secret to improve ROP protection. Returns 0 on success, -1 on error (e.g. if the secret is set after the instructions are loaded). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb0990b88e11d2a0ba89fbaf8086cc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0990b88e11d2a0ba89fbaf8086cc0f">&#9670;&nbsp;</a></span>ubpf_set_registers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubpf_set_registers </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>regs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override the storage location for the BPF registers in the VM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to set the register storage in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regs</td><td>The register storage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0046484ecdb72363d0c5ae710e7b96c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0046484ecdb72363d0c5ae710e7b96c3">&#9670;&nbsp;</a></span>ubpf_set_unwind_function_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_set_unwind_function_index </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instruct the uBPF runtime to apply unwind-on-success semantics to a helper function. If the function returns 0, the uBPF runtime will end execution of the eBPF program and immediately return control to the caller. This is used for implementing function like the "bpf_tail_call" helper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to set the unwind helper in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index of the helper function to unwind on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80938918080712ac0667359fd163f1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80938918080712ac0667359fd163f1a5">&#9670;&nbsp;</a></span>ubpf_toggle_bounds_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ubpf_toggle_bounds_check </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable / disable bounds_check. Bounds check is enabled by default, but it may be too restrictive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to enable / disable bounds check on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>Enable bounds check if true, disable if false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Bounds check was previously enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab34e26c0a46366345df354ce992448c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34e26c0a46366345df354ce992448c4">&#9670;&nbsp;</a></span>ubpf_translate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ubpf_translate </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>errmsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate the eBPF byte code to x64 machine code. </p>
<p>A program must be loaded into the VM and all external functions must be registered before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to translate the program in. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer to store the translated code in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errmsg</td><td>The error message, if any. This should be freed by the caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae95b334d7eeb18072da3b9f4eeb66c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95b334d7eeb18072da3b9f4eeb66c25">&#9670;&nbsp;</a></span>ubpf_unload_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubpf_unload_code </td>
          <td>(</td>
          <td class="paramtype">struct ubpf_vm *&#160;</td>
          <td class="paramname"><em>vm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unload code from a VM. </p>
<p>The VM must be reloaded with code before calling ubpf_exec or ubpf_compile.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vm</td><td>The VM to unload the code from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
